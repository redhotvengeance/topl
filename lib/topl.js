// Generated by CoffeeScript 1.7.1

/*!
 * topl (v0.3.0) - a TOML parser for JavaScript
 * Copyright (c) 2014 Ian Lollar (rhv@redhotvengeance.com)
 * Distributed under The MIT License
 * https://github.com/redhotvengeance/topl
 */


/* PUBLIC */

(function() {
  var error, getValue, killComment, makeArray, makeKey, makeTable, nextCharacter, parse, parseBoolean, parseNumber, parseString, progress, stripWhitespace, trimWhitespace;

  parse = (function(_this) {
    return function(data) {
      var line, lines, _i, _len;
      _this.parsed = {};
      _this.index = -1;
      _this.line = 1;
      _this.currentCharacter = '';
      _this.currentObject = _this.parsed;
      _this.currentKey = '';
      _this.tableKeys = [];
      lines = data.toString().replace(/\r\n/g, "\n").split("\n");
      lines.push('');
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        line = trimWhitespace(line);
      }
      _this.text = lines.join('\n');
      while (progress()) {
        switch (_this.currentCharacter) {
          case ' ':
            progress();
            break;
          case '#':
            killComment();
            break;
          case '[':
            makeTable();
            break;
          default:
            makeKey();
        }
      }
      return _this.parsed;
    };
  })(this);


  /* PRIVATE */

  error = (function(_this) {
    return function(message) {
      throw new Error(message);
    };
  })(this);

  progress = (function(_this) {
    return function(char) {
      if (char && char !== nextCharacter()) {
        error("Syntax error on line " + _this.line);
      }
      if (_this.currentCharacter === '\n') {
        _this.line++;
      }
      _this.index++;
      return _this.currentCharacter = _this.text.charAt(_this.index);
    };
  })(this);

  nextCharacter = (function(_this) {
    return function() {
      return _this.text.charAt(_this.index + 1);
    };
  })(this);

  stripWhitespace = (function(_this) {
    return function() {
      var _results;
      if (nextCharacter() === ' ' || nextCharacter() === '\t') {
        _results = [];
        while (progress()) {
          if (nextCharacter() !== ' ' && nextCharacter() !== '\t') {
            break;
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
  })(this);

  trimWhitespace = (function(_this) {
    return function(text) {
      return text.replace(/^[\s]+/, '').replace(/[\s]+$/, '');
    };
  })(this);

  killComment = (function(_this) {
    return function() {
      var _results;
      _results = [];
      while (progress()) {
        if (_this.currentCharacter === '\n' || nextCharacter() === '\n') {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
  })(this);

  parseString = (function(_this) {
    return function() {
      var char, hex, num, string, uffff, _i;
      string = '';
      if (nextCharacter() !== '"') {
        while (progress()) {
          if (_this.currentCharacter === '\\') {
            progress();
            if (_this.currentCharacter === 'u') {
              uffff = 0;
              for (num = _i = 1; _i <= 4; num = ++_i) {
                hex = parseInt(progress(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              string += String.fromCharCode(uffff);
            } else {
              char = '';
              switch (_this.currentCharacter) {
                case 'b':
                  char = '\b';
                  break;
                case 't':
                  char = '\t';
                  break;
                case 'n':
                  char = '\n';
                  break;
                case 'f':
                  char = '\f';
                  break;
                case 'r':
                  char = '\r';
                  break;
                case '"':
                  char = '\"';
                  break;
                case '/':
                  char = '\/';
                  break;
                case '\\':
                  char = '\\';
                  break;
                default:
                  error("Whatever you're trying to escape on line " + _this.line + " isn't supported. Try adding it in Unicode (\\uXXXX).");
              }
              string += char;
            }
          } else {
            string += _this.currentCharacter;
          }
          if (nextCharacter() === '"') {
            break;
          }
        }
      }
      progress();
      return {
        type: 'string',
        value: string
      };
    };
  })(this);

  parseNumber = (function(_this) {
    return function() {
      var number, result, type;
      number = _this.currentCharacter;
      if (/[.Z:T\d-]/.test(nextCharacter())) {
        while (progress()) {
          number += _this.currentCharacter;
          if (!(/[.Z:T\d-]/.test(nextCharacter()))) {
            break;
          }
        }
      }
      if (/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/.test(number)) {
        type = 'date';
        result = new Date(number);
      } else if (/^-?(\d+)?\.\d+$/.test(number)) {
        type = 'float';
        result = parseFloat(number);
      } else if (/^-?\d+$/.test(number)) {
        type = 'integer';
        result = parseInt(number);
      } else {
        error("Invalid primitive type on line " + _this.line);
      }
      return {
        type: type,
        value: result
      };
    };
  })(this);

  parseBoolean = (function(_this) {
    return function() {
      var result;
      switch (_this.currentCharacter.toLowerCase()) {
        case 't':
          progress('r');
          progress('u');
          progress('e');
          result = true;
          break;
        case 'f':
          progress('a');
          progress('l');
          progress('s');
          progress('e');
          result = false;
          break;
        default:
          error("Invalid primitive type on line " + _this.line);
      }
      return {
        type: 'boolean',
        value: result
      };
    };
  })(this);

  makeArray = (function(_this) {
    return function() {
      var array, type, value;
      array = [];
      type = null;
      stripWhitespace();
      while (progress()) {
        value = getValue();
        if (value) {
          if (!type) {
            type = value.type;
          }
          if (value.type !== type) {
            error("Array on line " + _this.line + " is mixing data types! That is a TOML no-no.");
          }
          array.push(value.value);
          stripWhitespace();
          progress();
        }
        if (_this.currentCharacter === ',' || _this.currentCharacter === '\n') {
          stripWhitespace();
        } else if (_this.currentCharacter === ']') {
          break;
        }
      }
      return {
        type: 'array',
        value: array
      };
    };
  })(this);

  makeTable = (function(_this) {
    return function() {
      var array, i, key, last, table, tableArray, tableKey, _i, _j, _len, _len1, _ref;
      stripWhitespace();
      progress();
      array = false;
      if (_this.currentCharacter === '[') {
        array = true;
        stripWhitespace();
        progress();
      }
      key = _this.currentCharacter;
      if (nextCharacter() !== ']') {
        while (progress()) {
          if (_this.currentCharacter !== '[' && _this.currentCharacter !== '#') {
            key += _this.currentCharacter;
          } else {
            error("Improper table declaration on line " + _this.line);
          }
          if (nextCharacter() === ']') {
            break;
          }
        }
      }
      progress();
      stripWhitespace();
      key = trimWhitespace(key);
      if (array) {
        progress();
        stripWhitespace();
      }
      if (nextCharacter() !== '\n' && nextCharacter() !== '#') {
        error("Improper table declaration on line " + _this.line);
      }
      tableArray = key.split('.');
      _this.currentObject = _this.parsed;
      for (i = _i = 0, _len = tableArray.length; _i < _len; i = ++_i) {
        table = tableArray[i];
        table = trimWhitespace(table);
        last = false;
        if (table.length <= 0) {
          error("Improper table declaration on line " + _this.line);
        }
        if (i === tableArray.length - 1) {
          last = true;
        }
        if (_this.currentObject[table] == null) {
          if (array && last) {
            _this.currentObject[table] = [{}];
            _this.currentObject = _this.currentObject[table][0];
          } else {
            _this.currentObject[table] = {};
            _this.currentObject = _this.currentObject[table];
          }
        } else {
          if (array) {
            if (last) {
              if (!Array.isArray(_this.currentObject[table])) {
                error("Check your tables and keys! You\'re attempting an overwrite on line " + _this.line + "!");
              }
              _this.currentObject[table].push({});
              _this.currentObject = _this.currentObject[table][_this.currentObject[table].length - 1];
            } else {
              if (Array.isArray(_this.currentObject[table])) {
                _this.currentObject = _this.currentObject[table][_this.currentObject[table].length - 1];
              } else {
                _this.currentObject = _this.currentObject[table];
              }
            }
          } else {
            _ref = _this.tableKeys;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              tableKey = _ref[_j];
              if (tableKey === key) {
                error("Check your tables and keys! You\'re attempting an overwrite on line " + _this.line + "!");
              }
            }
            _this.currentObject = _this.currentObject[table];
            if (Array.isArray(_this.currentObject)) {
              _this.currentObject = _this.currentObject[_this.currentObject.length - 1];
            }
          }
        }
      }
      _this.tableKeys.push(key);
      return _this.currentKey = key;
    };
  })(this);

  makeKey = (function(_this) {
    return function() {
      var key, value;
      if (/[\w~!@#$^&*()_+-`1234567890\[\]\\|\/?><.,;:']/i.test(_this.currentCharacter)) {
        key = _this.currentCharacter;
        if (nextCharacter() !== '=') {
          while (progress()) {
            key += _this.currentCharacter;
            if (nextCharacter() === '=') {
              break;
            }
          }
        }
        stripWhitespace();
        key = trimWhitespace(key);
        if (progress() === '=') {
          stripWhitespace();
          progress();
          value = getValue();
        }
        if (!value) {
          error("Syntax error on line " + _this.line);
        }
        if (_this.currentObject[key] != null) {
          error("Trying to overwrite previously set value on line " + _this.line);
        }
        _this.currentObject[key] = value.value;
        _this.tableKeys.push("" + _this.currentKey + "." + key);
        stripWhitespace();
        if (nextCharacter() !== '\n' && nextCharacter() !== '#') {
          return error("Syntax error on line " + _this.line);
        }
      }
    };
  })(this);

  getValue = (function(_this) {
    return function() {
      var value, _ref;
      value = null;
      switch (_this.currentCharacter) {
        case '#':
          killComment();
          break;
        case '"':
          value = parseString();
          break;
        case "'":
          error("Check the string on line " + _this.line + "! TOML does not support single-quoted strings.");
          break;
        case '[':
          value = makeArray();
          break;
        case '-':
          value = parseNumber();
          break;
        case ']':
          break;
        case '\n':
          stripWhitespace();
          break;
        default:
          if (('0' <= (_ref = _this.currentCharacter) && _ref <= '9')) {
            value = parseNumber();
          } else {
            value = parseBoolean();
            if (value === null) {
              error("Invalid primitive type on line " + _this.line);
            }
          }
      }
      return value;
    };
  })(this);

  if (typeof Array.isArray === 'undefined') {
    Array.isArray = function(obj) {
      return Object.toString.call(obj) === '[object] Array';
    };
  }

  if (typeof exports !== "undefined" && exports !== null) {
    exports.parse = parse;
  } else {
    this['topl'] = {};
    this['topl']['parse'] = parse;
  }

}).call(this);
